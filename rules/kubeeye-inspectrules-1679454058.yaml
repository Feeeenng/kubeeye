apiVersion: kubeeye.kubesphere.io/v1alpha2
kind: InspectRules
metadata:
  creationTimestamp: null
  labels:
    app.kubernetes.io/created-by: kubeeye
    app.kubernetes.io/instance: inspectrules-sample
    app.kubernetes.io/managed-by: kustomize
    app.kubernetes.io/name: inspectrules
    app.kubernetes.io/part-of: kubeeye
  name: kubeeye-inspectrules-1679454058
  namespace: kubeeye-system
spec:
  rules:
  - desc: kubeeye_workloads_rego
    opa: |-
      package kubeeye_workloads_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Pod"
          level := "danger"

          PodSetCPULimits(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NoCPULimits"
          }
      }

      PodSetCPULimits(resource) {
          containers := resource.Object.spec.containers[_]
          not containers.resources.limits.cpu
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
          workloadsType[type]
          level := "danger"

          workloadsSetCPULimits(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NoCPULimits"
          }
      }

      workloadsSetCPULimits(resource) {
          containers := resource.Object.spec.template.spec.containers[_]
          not containers.resources.limits.cpu
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "CronJob"
          level := "danger"

          CronjobSetCPULimits(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NoCPULimits"
          }
      }

      CronjobSetCPULimits(resource) {
          containers := resource.Object.spec.jobTemplate.spec.template.spec.containers[_]
          not containers.resources.limits.cpu
      }
    ruleName: CPULimitsRule
    tags:
    - kubeeye_workloads_rego
  - desc: kubeeye_workloads_rego
    opa: |-
      package kubeeye_workloads_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Pod"
          level := "danger"

          PodSetCPURequests(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NoCPURequests"
          }
      }

      PodSetCPURequests(resource) {
              containers := resource.Object.spec.containers[_]
              not containers.resources.requests.cpu
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
          workloadsType[type]
          level := "danger"

          workloadsSetCPURequests(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NoCPURequests"
          }
      }

      workloadsSetCPURequests(resource) {
          containers := resource.Object.spec.template.spec.containers[_]
          not containers.resources.requests.cpu
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "CronJob"
          level := "danger"

          CronjobSetCPURequests(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NoCPURequests"
          }
      }

      CronjobSetCPURequests(resource) {
          containers := resource.Object.spec.jobTemplate.spec.template.spec.containers[_]
          not containers.resources.requests.cpu
      }
    ruleName: CPURequestsRule
    tags:
    - kubeeye_workloads_rego
  - desc: kubeeye_events_rego
    opa: |-
      package kubeeye_events_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Event"
          level := "warning"
          Message := resource.Object.reason
          Reason := resource.Object.message

          resource.Object.type != "Normal"

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": sprintf("%v", [Message]),
              "Reason": sprintf("%v", [Reason]),
          }
      }
    ruleName: ExceptionEventsRule
    tags:
    - kubeeye_events_rego
  - desc: kubeeye_nodes_rego
    opa: |-
      package kubeeye_nodes_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          type == "Node"
          level := "warning"

          resource.Object.status.conditions[i].status == "False"

          contains(resource.Object.status.conditions[i].message, "has")
          not contains(resource.Object.status.conditions[i].message, "has no")
          Message := replace(resource.Object.status.conditions[i].message,"has", "has no")
          contains(resource.Object.status.conditions[i].reason, "Has")
          not contains(resource.Object.status.conditions[i].reason, "HasNo")
          Reason := replace(resource.Object.status.conditions[i].reason,"Has", "HasNo")

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": sprintf("%v", [Reason]),
              "Reason": sprintf("%v", [Message]),
          }
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          type == "Node"
          level := "warning"

          resource.Object.status.conditions[i].status == "False"

          contains(resource.Object.status.conditions[i].message, "has no")
          Message := replace(resource.Object.status.conditions[i].message,"has no", "has")
          contains(resource.Object.status.conditions[i].reason, "HasNo")
          Reason := replace(resource.Object.status.conditions[i].reason,"HasNo", "Has")

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": sprintf("%v", [Reason]),
              "Reason": sprintf("%v", [Message]),
          }
      }
    ruleName: FalseNodeConditionsRule
    tags:
    - kubeeye_nodes_rego
  - desc: kubeeye_workloads_rego
    opa: |-
      package kubeeye_workloads_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Pod"
          level := "danger"

          PodSetallowPrivilegeEscalation(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "PrivilegeEscalationAllowed"
          }
      }

      PodSetallowPrivilegeEscalation(resource) {
          resource.Object.spec.securityContext.allowPrivilegeEscalation == true
      } else {
          resource.Object.spec.containers[_].securityContext.allowPrivilegeEscalation == true
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
          workloadsType[type]
          level := "danger"

          DownloadsSetallowPrivilegeEscalation(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "PrivilegeEscalationAllowed"
          }
      }

      DownloadsSetallowPrivilegeEscalation(resource) {
          resource.Object.spec.template.spec.containers[_].securityContext.allowPrivilegeEscalation == true
      } else {
          resource.Object.spec.template.spec.securityContext.allowPrivilegeEscalation == true
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "CronJob"
          level := "danger"

          CronjobSetallowPrivilegeEscalation(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "PrivilegeEscalationAllowed"
          }
      }

      CronjobSetallowPrivilegeEscalation(resource) {
          resource.Object.spec.jobTemplate.spec.template.spec.containers[_].securityContext.allowPrivilegeEscalation == true
      } else {
          resource.Object.spec.jobTemplate.spec.template.spec.securityContext.allowPrivilegeEscalation == true
      }
    ruleName: allowPrivilegeEscalationRule
    tags:
    - kubeeye_workloads_rego
  - desc: kubeeye_RBAC_rego
    opa: |-
      package kubeeye_RBAC_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Role"
          level := "warning"

          isNotDefaultRBAC(resource)
          canImpersonateUserResource(resource)
          haveImpersonateUserResourceVerb(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "CanImpersonateUser"
          }
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          type == "ClusterRole"
          level := "warning"

          isNotDefaultRBAC(resource)
          canImpersonateUserResource(resource)
          haveImpersonateUserResourceVerb(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "CanImpersonateUser"
          }
      }

      isNotDefaultRBAC(resource) {
          not resource.Object.metadata.labels["kubernetes.io/bootstrapping"] == "rbac-defaults"
      }

      canImpersonateUserResource(resource){
          resource.Object.rules[_].resources[_] == "users"
      }

      canImpersonateUserResource(resource){
          resource.Object.rules[_].resources[_] == "groups"
      }

      canImpersonateUserResource(resource){
          resource.Object.rules[_].resources[_] == "serviceaccounts"
      }

      canImpersonateUserResource(resource){
          resource.Object.rules[_].resources[_] == "*"
      }

      haveImpersonateUserResourceVerb(resource){
          resource.Object.rules[_].verbs[_] == "impersonate"
      }

      haveImpersonateUserResourceVerb(resource){
          resource.Object.rules[_].verbs[_] == "*"
      }
    ruleName: canImpersonateUserRoleRule
    tags:
    - kubeeye_RBAC_rego
  - desc: kubeeye_RBAC_rego
    opa: |-
      package kubeeye_RBAC_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Role"
          level := "warning"

          isNotDefaultRBAC(resource)
          canModifyResources(resource)
          haveModifyResourcesVerb(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "CanDeleteResources"
          }
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          type == "ClusterRole"
          level := "warning"

          isNotDefaultRBAC(resource)
          canModifyResources(resource)
          haveModifyResourcesVerb(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "CanDeleteResources"
          }
      }

      isNotDefaultRBAC(resource) {
          not resource.Object.metadata.labels["kubernetes.io/bootstrapping"] == "rbac-defaults"
      }

      canModifyResources(resource){
          resource.Object.rules[_].resources[_] == "secrets"
      }

      canModifyResources(resource){
          resource.Object.rules[_].resources[_] == "configmaps"
      }

      canModifyResources(resource){
          resource.Object.rules[_].resources[_] == "persistentvolumeclaims"
      }

      canModifyResources(resource){
          resource.Object.rules[_].resources[_] == "horizontalpodautoscalers"
      }

      canModifyResources(resource){
          resource.Object.rules[_].resources[_] == "events"
      }

      canModifyResources(resource){
          resource.Object.rules[_].resources[_] == "roles"
      }

      canModifyResources(resource){
          resource.Object.rules[_].resources[_] == "clusterroles"
      }

      canModifyResources(resource){
          resource.Object.rules[_].resources[_] == "users"
      }

      canModifyResources(resource){
          resource.Object.rules[_].resources[_] == "groups"
      }

      canModifyResources(resource){
          resource.Object.rules[_].resources[_] == "serviceaccounts"
      }


      canModifyResources(resource){
          resource.Object.rules[_].resources[_] == "services"
      }

      canModifyResources(resource){
          resource.Object.rules[_].resources[_] == "ingresses"
      }

      canModifyResources(resource){
          resource.Object.rules[_].resources[_] == "endpoints"
      }

      canModifyResources(resource){
          resource.Object.rules[_].resources[_] == "networkpolicies"
      }

      canModifyResources(resource){
          resource.Object.rules[_].resources[_] == "certificates"
      }

      canModifyResources(resource){
          resource.Object.rules[_].resources[_] == "certificaterequests"
      }

      canModifyResources(resource){
          resource.Object.rules[_].resources[_] == "issuers"
      }

      canModifyResources(resource){
          resource.Object.rules[_].resources[_] == "*"
      }

      haveModifyResourcesVerb(resource){
          resource.Object.rules[_].verbs[_] == "create"
      }

      haveModifyResourcesVerb(resource){
          resource.Object.rules[_].verbs[_] == "update"
      }

      haveModifyResourcesVerb(resource){
          resource.Object.rules[_].verbs[_] == "patch"
      }

      haveModifyResourcesVerb(resource){
          resource.Object.rules[_].verbs[_] == "delete"
      }

      haveModifyResourcesVerb(resource){
          resource.Object.rules[_].verbs[_] == "deletecollection"
      }

      haveModifyResourcesVerb(resource){
          resource.Object.rules[_].verbs[_] == "*"
      }
    ruleName: canModifyResourcesRoleRule
    tags:
    - kubeeye_RBAC_rego
  - desc: kubeeye_RBAC_rego
    opa: |-
      package kubeeye_RBAC_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Role"
          level := "warning"

          isNotDefaultRBAC(resource)
          canModifyPodResource(resource)
          haveModifyPodResourceVerb(resource)


          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "CanModifyWorkloads"
          }
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          type == "ClusterRole"
          level := "warning"

          isNotDefaultRBAC(resource)
          canModifyPodResource(resource)
          haveModifyPodResourceVerb(resource)


          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "CanModifyWorkloads"
          }
      }

      isNotDefaultRBAC(resource) {
          not resource.Object.metadata.labels["kubernetes.io/bootstrapping"] == "rbac-defaults"
      }

      canModifyPodResource(resource){
          resource.Object.rules[_].resources[_] == "pods"
      }

      canModifyPodResource(resource){
          resource.Object.rules[_].resources[_] == "deployments"
      }

      canModifyPodResource(resource){
          resource.Object.rules[_].resources[_] == "daemonsets"
      }

      canModifyPodResource(resource){
          resource.Object.rules[_].resources[_] == "replicasets"
      }

      canModifyPodResource(resource){
          resource.Object.rules[_].resources[_] == "statefulsets"
      }

      canModifyPodResource(resource){
          resource.Object.rules[_].resources[_] == "jobs"
      }

      canModifyPodResource(resource){
          resource.Object.rules[_].resources[_] == "cronjobs"
      }

      canModifyPodResource(resource){
          resource.Object.rules[_].resources[_] == "replicationcontrollers"
      }

      canModifyPodResource(resource){
          resource.Object.rules[_].resources[_] == "*"
      }

      haveModifyPodResourceVerb(resource){
          resource.Object.rules[_].verbs[_] == "create"
      }

      haveModifyPodResourceVerb(resource){
          resource.Object.rules[_].verbs[_] == "update"
      }

      haveModifyPodResourceVerb(resource){
          resource.Object.rules[_].verbs[_] == "patch"
      }

      haveModifyPodResourceVerb(resource){
          resource.Object.rules[_].verbs[_] == "delete"
      }

      haveModifyPodResourceVerb(resource){
          resource.Object.rules[_].verbs[_] == "deletecollection"
      }

      haveModifyPodResourceVerb(resource){
          resource.Object.rules[_].verbs[_] == "*"
      }
    ruleName: canModifyWorkloadsRoleRule
    tags:
    - kubeeye_RBAC_rego
  - desc: kubeeye_workloads_rego
    opa: |-
      package kubeeye_workloads_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Pod"
          level := "danger"

          PodSetHighRiskCapabilities(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "HighRiskCapabilities"
          }
      }

      PodSetHighRiskCapabilities(resource) {
          HighRiskCapabilities := ["NET_ADMIN", "SYS_ADMIN", "ALL"]
          containers := resource.Object.spec.containers[_]
          HighRiskCapabilities[_] == containers.securityContext.capabilities.add[_]
      } else {
          HighRiskCapabilities := ["NET_ADMIN", "SYS_ADMIN", "ALL"]
          HighRiskCapabilities[_] == resource.Object.spec.securityContext.capabilities.add[_]
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
          workloadsType[type]
          level := "danger"

          WorkloadsSetHighRiskCapabilities(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "HighRiskCapabilities"
          }
      }

      WorkloadsSetHighRiskCapabilities(resource) {
          HighRiskCapabilities := ["NET_ADMIN", "SYS_ADMIN", "ALL"]
          containers := resource.Object.spec.template.spec.containers[_]
          HighRiskCapabilities[_] == containers.securityContext.capabilities.add[_]
      } else {
          HighRiskCapabilities := ["NET_ADMIN", "SYS_ADMIN", "ALL"]
          HighRiskCapabilities[_] == resource.Object.spec.template.spec.securityContext.capabilities.add[_]
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "CronJob"
          level := "danger"

          CronjobSetHighRiskCapabilities(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "HighRiskCapabilities"
          }
      }

      CronjobSetHighRiskCapabilities(resource) {
          HighRiskCapabilities := ["NET_ADMIN", "SYS_ADMIN", "ALL"]
          containers := resource.Object.spec.jobTemplate.spec.template.spec.containers[_]
          HighRiskCapabilities[_] == containers.securityContext.capabilities.add[_]
      } else {
          HighRiskCapabilities := ["NET_ADMIN", "SYS_ADMIN", "ALL"]
          HighRiskCapabilities[_] == resource.Object.spec.jobTemplate.spec.template.spec.securityContext.capabilities.add[_]
      }
    ruleName: highRiskCapabilitiesRule
    tags:
    - kubeeye_workloads_rego
  - desc: kubeeye_workloads_rego
    opa: |-
      package kubeeye_workloads_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Pod"
          level := "danger"

          PodSethostIPC(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "HostIPCAllowed"
          }
      }

      PodSethostIPC(resource) {
          resource.Object.spec.hostIPC == true
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
          workloadsType[type]
          level := "danger"

          workloadsSethostIPC(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "HostIPCAllowed"
          }
      }

      workloadsSethostIPC(resource) {
          resource.Object.spec.template.spec.hostIPC == true
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "CronJob"
          level := "danger"

          CronJobSethostIPC(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "HostIPCAllowed"
          }
      }

      CronJobSethostIPC(resource) {
          resource.Object.spec.jobTemplate.spec.template.spec.hostIPC == true
      }
    ruleName: hostIPCRule
    tags:
    - kubeeye_workloads_rego
  - desc: kubeeye_workloads_rego
    opa: |-
      package kubeeye_workloads_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Pod"
          level := "danger"

          PodSethostNetwork(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "HostNetworkAllowed"
          }
      }

      PodSethostNetwork(resource) {
          resource.Object.spec.hostNetwork == true
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
          workloadsType[type]
          level := "danger"

          workloadsSethostNetwork(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "HostNetworkAllowed"
          }
      }

      workloadsSethostNetwork(resource) {
          resource.Object.spec.template.spec.hostNetwork == true
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "CronJob"
          level := "danger"

          CronJobSethostNetwork(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "HostNetworkAllowed"
          }
      }

      CronJobSethostNetwork(resource) {
          resource.Object.spec.jobTemplate.spec.template.spec.hostNetwork == true
      }
    ruleName: hostNetworkRule
    tags:
    - kubeeye_workloads_rego
  - desc: kubeeye_workloads_rego
    opa: |-
      package kubeeye_workloads_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Pod"
          level := "danger"

          PodSethostPID(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "HostPIDAllowed"
          }
      }

      PodSethostPID(resource) {
          resource.Object.spec.hostPID == true
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
          workloadsType[type]
          level := "danger"

          workloadsSethostPID(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "HostPIDAllowed"
          }
      }

      workloadsSethostPID(resource) {
          resource.Object.spec.template.spec.hostPID == true
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "CronJob"
          level := "danger"

          CronJobSethostPID(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "HostPIDAllowed"
          }
      }

      CronJobSethostPID(resource) {
          resource.Object.spec.jobTemplate.spec.template.spec.hostPID == true
      }
    ruleName: hostPIDRule
    tags:
    - kubeeye_workloads_rego
  - desc: kubeeye_workloads_rego
    opa: |-
      package kubeeye_workloads_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Pod"
          level := "danger"

          PodSethostPort(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "HostPortAllowed"
          }
      }

      PodSethostPort(resource) {
          resource.Object.spec.containers[_].ports[_].hostPort
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
          workloadsType[type]
          level := "danger"

          workloadsSethostPort(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "HostPortAllowed"
          }
      }

      workloadsSethostPort(resource) {
          resource.Object.spec.template.spec.containers[_].ports[_].hostPort
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "CronJob"
          level := "danger"

          CronJobSethostPort(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "HostPortAllowed"
          }
      }

      CronJobSethostPort(resource) {
          resource.Object.spec.jobTemplate.spec.template.spec.containers[_].ports[_].hostPort
      }
    ruleName: hostPortRule
    tags:
    - kubeeye_workloads_rego
  - desc: kubeeye_workloads_rego
    opa: |-
      package kubeeye_workloads_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Pod"
          level := "warning"

          PodimagePullPolicyRule(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "ImagePullPolicyNotAlways"
          }
      }

      PodimagePullPolicyRule(resource) {
          imagePullPolicy := resource.Object.spec.containers[_].imagePullPolicy
          imagePullPolicy != "Always"
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
          workloadsType[type]
          level := "warning"

          workloadsimagePullPolicyRule(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "ImagePullPolicyNotAlways"
          }
      }

      workloadsimagePullPolicyRule(resource) {
          imagePullPolicy := resource.Object.spec.template.spec.containers[_].imagePullPolicy
          imagePullPolicy != "Always"
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "CronJob"
          level := "warning"

          CronJobimagePullPolicyRule(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "ImagePullPolicyNotAlways"
          }
      }

      CronJobimagePullPolicyRule(resource) {
          imagePullPolicy := resource.Object.spec.jobTemplate.spec.template.spec.containers[_].imagePullPolicy
          imagePullPolicy != "Always"
      }
    ruleName: imagePullPolicyRule
    tags:
    - kubeeye_workloads_rego
  - desc: kubeeye_workloads_rego
    opa: |-
      package kubeeye_workloads_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Pod"
          level := "danger"

          not PodImageTagRule(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "ImageTagMiss"
          }
      }

      PodImageTagRule(resource) {
          regex.match("^.+:.+$", input.Object.spec.containers[_].image)
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
          workloadsType[type]
          level := "danger"

          not workloadsImageTagRule(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "ImageTagMiss"
          }
      }

      workloadsImageTagRule(resource) {
          regex.match("^.+:.+$", resource.Object.spec.template.spec.containers[_].image)
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "CronJob"
          level := "danger"

          not CronJobImageTagRule(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "ImageTagMiss"
          }
      }

      CronJobImageTagRule(resource) {
          regex.match("^.+:.+", resource.Object.spec.jobTemplate.spec.template.spec.containers[_].image)
      }
    ruleName: imageTagMissingRule
    tags:
    - kubeeye_workloads_rego
  - desc: kubeeye_workloads_rego
    opa: |-
      package kubeeye_workloads_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Pod"
          level := "warning"

          PodImageTagRule(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "ImageTagIsLatest"
          }
      }

      PodImageTagRule(resource) {
          regex.match("^.+:latest$", input.Object.spec.containers[_].image)
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
          workloadsType[type]
          level := "warning"

          workloadsImageTagRule(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "ImageTagIsLatest"
          }
      }

      workloadsImageTagRule(resource) {
          regex.match("^.+:latest$", resource.Object.spec.template.spec.containers[_].image)
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "CronJob"
          level := "warning"

          CronJobImageTagRule(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "ImageTagIsLatest"
          }
      }

      CronJobImageTagRule(resource) {
          regex.match("^.+:latest$", resource.Object.spec.jobTemplate.spec.template.spec.containers[_].image)
      }
    ruleName: imageTagRule
    tags:
    - kubeeye_workloads_rego
  - desc: kubeeye_workloads_rego
    opa: |-
      package kubeeye_workloads_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Pod"
          level := "warning"

          PodSetInsecureCapabilities(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "InsecureCapabilities"
          }
      }

      PodSetInsecureCapabilities(resource) {
          insecureCapabilities := ["CHOWN", "DAC_OVERRIDE", "FSETID", "FOWNER", "MKNOD", "NET_RAW", "SETGID", "SETUID", "SETFCAP", "NET_BIND_SERVICE","SYS_CHROOT","KILL","AUDIT_WRITE"]
          containers := resource.Object.spec.containers[_]
          insecureCapabilities[_] == containers.securityContext.capabilities.add[_]
      } else {
          insecureCapabilities := ["CHOWN", "DAC_OVERRIDE", "FSETID", "FOWNER", "MKNOD", "NET_RAW", "SETGID", "SETUID", "SETFCAP", "NET_BIND_SERVICE","SYS_CHROOT","KILL","AUDIT_WRITE"]
          insecureCapabilities[_] == resource.Object.spec.securityContext.capabilities.add[_]
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
          workloadsType[type]
          level := "warning"

          WorkloadsSetInsecureCapabilities(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "InsecureCapabilities"
          }
      }

      WorkloadsSetInsecureCapabilities(resource) {
          insecureCapabilities := ["CHOWN", "DAC_OVERRIDE", "FSETID", "FOWNER", "MKNOD", "NET_RAW", "SETGID", "SETUID", "SETFCAP", "NET_BIND_SERVICE","SYS_CHROOT","KILL","AUDIT_WRITE"]
          containers := resource.Object.spec.template.spec.containers[_]
          insecureCapabilities[_] == containers.securityContext.capabilities.add[_]
      } else {
          insecureCapabilities := ["CHOWN", "DAC_OVERRIDE", "FSETID", "FOWNER", "MKNOD", "NET_RAW", "SETGID", "SETUID", "SETFCAP", "NET_BIND_SERVICE","SYS_CHROOT","KILL","AUDIT_WRITE"]
          insecureCapabilities[_] == resource.Object.spec.template.spec.securityContext.capabilities.add[_]
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "CronJob"
          level := "warning"

          CronjobSetInsecureCapabilities(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "InsecureCapabilities"
          }
      }

      CronjobSetInsecureCapabilities(resource) {
          insecureCapabilities := ["CHOWN", "DAC_OVERRIDE", "FSETID", "FOWNER", "MKNOD", "NET_RAW", "SETGID", "SETUID", "SETFCAP", "NET_BIND_SERVICE","SYS_CHROOT","KILL","AUDIT_WRITE"]
          containers := resource.Object.spec.jobTemplate.spec.template.spec.containers[_]
          insecureCapabilities[_] == containers.securityContext.capabilities.add[_]
      } else {
          insecureCapabilities := ["CHOWN", "DAC_OVERRIDE", "FSETID", "FOWNER", "MKNOD", "NET_RAW", "SETGID", "SETUID", "SETFCAP", "NET_BIND_SERVICE","SYS_CHROOT","KILL","AUDIT_WRITE"]
          insecureCapabilities[_] == resource.Object.spec.jobTemplate.spec.template.spec.securityContext.capabilities.add[_]
      }
    ruleName: insecureCapabilitiesRule
    tags:
    - kubeeye_workloads_rego
  - desc: kubeeye_workloads_rego
    opa: |-
      package kubeeye_workloads_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Pod"
          level := "warning"

          PodSetlivenessProbe(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NoLivenessProbe"
          }
      }

      PodSetlivenessProbe(resource) {
          containers := resource.Object.spec.containers[_]
          not containers.livenessProbe
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
          workloadsType[type]
          level := "warning"

          workloadsSetlivenessProbe(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NoLivenessProbe"
          }
      }

      workloadsSetlivenessProbe(resource) {
          containers := resource.Object.spec.template.spec.containers[_]
          not containers.livenessProbe
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "CronJob"
          level := "warning"

          CronjobSetlivenessProbe(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NoLivenessProbe"
          }
      }

      CronjobSetlivenessProbe(resource) {
          containers := resource.Object.spec.jobTemplate.spec.template.spec.containers[_]
          not containers.livenessProbe
      }
    ruleName: livenessProbeRule
    tags:
    - kubeeye_workloads_rego
  - desc: kubeeye_workloads_rego
    opa: |-
      package kubeeye_workloads_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Pod"
          level := "danger"

          PodSetMemoryLimits(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NoMemoryLimits"
          }
      }

      PodSetMemoryLimits(resource) {
          containers := resource.Object.spec.containers[_]
          not containers.resources.limits.memory
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
          workloadsType[type]
          level := "danger"

          workloadsSetMemoryLimits(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NoMemoryLimits"
          }
      }

      workloadsSetMemoryLimits(resource) {
          containers := resource.Object.spec.template.spec.containers[_]
          not containers.resources.limits.memory
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "CronJob"
          level := "danger"

          CronjobSetMemoryLimits(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NoMemoryLimits"
          }
      }

      CronjobSetMemoryLimits(resource) {
          containers := resource.Object.spec.jobTemplate.spec.template.spec.containers[_]
          not containers.resources.limits.memory
      }
    ruleName: memoryLimitsRule
    tags:
    - kubeeye_workloads_rego
  - desc: kubeeye_workloads_rego
    opa: |-
      package kubeeye_workloads_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Pod"
          level := "danger"

          PodSetMemoryRequests(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NoMemoryRequests"
          }
      }

      PodSetMemoryRequests(resource) {
          containers := resource.Object.spec.containers[_]
          not containers.resources.requests.memory
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
          workloadsType[type]
          level := "danger"

          workloadsSetMemoryRequests(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NoMemoryRequests"
          }
      }

      workloadsSetMemoryRequests(resource) {
          containers := resource.Object.spec.template.spec.containers[_]
          not containers.resources.requests.memory
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "CronJob"
          level := "danger"

          CronjobSetMemoryRequests(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NoMemoryRequests"
          }
      }

      CronjobSetMemoryRequests(resource) {
          containers := resource.Object.spec.jobTemplate.spec.template.spec.containers[_]
          not containers.resources.requests.memory
      }
    ruleName: memoryRequestsRule
    tags:
    - kubeeye_workloads_rego
  - desc: kubeeye_workloads_rego
    opa: |-
      package kubeeye_workloads_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Pod"
          level := "ignore"

          PodPriorityClassNameRule(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NoPriorityClassName"
          }
      }

      PodPriorityClassNameRule(resource) {
          not resource.Object.spec.priorityClassName
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
          workloadsType[type]
          level := "ignore"

          workloadsPriorityClassNameRule(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NoPriorityClassName"
          }
      }

      workloadsPriorityClassNameRule(resource) {
          not resource.Object.spec.template.spec.priorityClassName
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "CronJob"
          level := "ignore"

          CronJobPriorityClassNameRule(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NoPriorityClassName"
          }
      }

      CronJobPriorityClassNameRule(resource) {
          not resource.Object.spec.jobTemplate.spec.template.spec.priorityClassName
      }
    ruleName: priorityClassRule
    tags:
    - kubeeye_workloads_rego
  - desc: kubeeye_workloads_rego
    opa: |-
      package kubeeye_workloads_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Pod"
          level := "danger"

          PodSetPrivilegedRule(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "PrivilegedAllowed"
          }
      }

      PodSetPrivilegedRule(resource) {
          resource.Object.spec.containers[_].securityContext.privileged == true
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
          workloadsType[type]
          level := "danger"

          workloadsSetPrivilegedRule(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "PrivilegedAllowed"
          }
      }

      workloadsSetPrivilegedRule(resource) {
          resource.Object.spec.template.spec.containers[_].securityContext.privileged == true
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "CronJob"
          level := "danger"

          CronJobSetPrivilegedRule(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "PrivilegedAllowed"
          }
      }

      CronJobSetPrivilegedRule(resource) {
          resource.Object.spec.jobTemplate.spec.template.spec.containers[_].securityContext.privileged == true
      }
    ruleName: privilegedRule
    tags:
    - kubeeye_workloads_rego
  - desc: kubeeye_workloads_rego
    opa: |-
      package kubeeye_workloads_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Pod"
          level := "warning"

          PodSetreadOnlyRootFilesystem(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NotReadOnlyRootFilesystem"
          }
      }

      PodSetreadOnlyRootFilesystem(resource) {
          not resource.Object.spec.securityContext.readOnlyRootFilesystem == true
          containers := resource.Object.spec.containers[_]
          not containers.securityContext.readOnlyRootFilesystem == true
      }
      PodSetreadOnlyRootFilesystem(resource) {
          not resource.Object.spec.securityContext.readOnlyRootFilesystem
          containers := resource.Object.spec.containers[_]
          not containers.securityContext.readOnlyRootFilesystem == true
      }
      PodSetreadOnlyRootFilesystem(resource) {
          not resource.Object.spec.securityContext.readOnlyRootFilesystem == true
          containers := resource.Object.spec.containers[_]
          not containers.securityContext.readOnlyRootFilesystem
      }
      PodSetreadOnlyRootFilesystem(resource) {
          not resource.Object.spec.securityContext.readOnlyRootFilesystem
          containers := resource.Object.spec.containers[_]
          not containers.securityContext.readOnlyRootFilesystem
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
          workloadsType[type]
          level := "warning"

          workloadsSetreadOnlyRootFilesystem(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NotReadOnlyRootFilesystem"
          }
      }

      workloadsSetreadOnlyRootFilesystem(resource) {
          not resource.Object.spec.securityContext.readOnlyRootFilesystem == true
          containers := resource.Object.spec.template.spec.containers[_]
          not containers.securityContext.readOnlyRootFilesystem == true
      }
      workloadsSetreadOnlyRootFilesystem(resource) {
          not resource.Object.spec.securityContext.readOnlyRootFilesystem
          containers := resource.Object.spec.template.spec.containers[_]
          not containers.securityContext.readOnlyRootFilesystem == true
      }
      workloadsSetreadOnlyRootFilesystem(resource) {
          not resource.Object.spec.securityContext.readOnlyRootFilesystem == true
          containers := resource.Object.spec.template.spec.containers[_]
          not containers.securityContext.readOnlyRootFilesystem
      }
      workloadsSetreadOnlyRootFilesystem(resource) {
          not resource.Object.spec.securityContext.readOnlyRootFilesystem
          containers := resource.Object.spec.template.spec.containers[_]
          not containers.securityContext.readOnlyRootFilesystem
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "CronJob"
          level := "warning"

          CronJobSetreadOnlyRootFilesystem(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NotReadOnlyRootFilesystem"
          }
      }

      CronJobSetreadOnlyRootFilesystem(resource) {
          not resource.Object.spec.securityContext.readOnlyRootFilesystem == true
          containers := resource.Object.spec.jobTemplate.spec.template.spec.containers[_]
          not containers.securityContext.readOnlyRootFilesystem == true
      }
      CronJobSetreadOnlyRootFilesystem(resource) {
          not resource.Object.spec.securityContext.readOnlyRootFilesystem
          containers := resource.Object.spec.jobTemplate.spec.template.spec.containers[_]
          not containers.securityContext.readOnlyRootFilesystem == true
      }
      CronJobSetreadOnlyRootFilesystem(resource) {
          not resource.Object.spec.securityContext.readOnlyRootFilesystem == true
          containers := resource.Object.spec.jobTemplate.spec.template.spec.containers[_]
          not containers.securityContext.readOnlyRootFilesystem
      }
      CronJobSetreadOnlyRootFilesystem(resource) {
          not resource.Object.spec.securityContext.readOnlyRootFilesystem
          containers := resource.Object.spec.jobTemplate.spec.template.spec.containers[_]
          not containers.securityContext.readOnlyRootFilesystem
      }
    ruleName: readOnlyRootFilesystemRule
    tags:
    - kubeeye_workloads_rego
  - desc: kubeeye_workloads_rego
    opa: |-
      package kubeeye_workloads_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Pod"
          level := "warning"

          PodSetreadinessProbe(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NoReadinessProbe"
          }
      }

      PodSetreadinessProbe(resource) {
          containers := resource.Object.spec.containers[_]
          not containers.readinessProbe
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
          workloadsType[type]
          level := "warning"

          workloadsSetreadinessProbe(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NoReadinessProbe"
          }
      }

      workloadsSetreadinessProbe(resource) {
          containers := resource.Object.spec.template.spec.containers[_]
          not containers.readinessProbe
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "CronJob"
          level := "warning"

          CronjobSetreadinessProbe(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NoReadinessProbe"
          }
      }

      CronjobSetreadinessProbe(resource) {
          containers := resource.Object.spec.jobTemplate.spec.template.spec.containers[_]
          not containers.readinessProbe
      }
    ruleName: readinessProbeRule
    tags:
    - kubeeye_workloads_rego
  - desc: kubeeye_workloads_rego
    opa: |-
      package kubeeye_workloads_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Pod"
          level := "warning"

          PodSetrunAsNonRoot(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NotRunAsNonRoot"
          }
      }

      PodSetrunAsNonRoot(resource) {
          not resource.Object.spec.securityContext.runAsNonRoot
          containers := resource.Object.spec.containers[_]
          not containers.securityContext.runAsNonRoot
      }
      PodSetrunAsNonRoot(resource) {
          resource.Object.spec.securityContext.runAsNonRoot == false
          containers := resource.Object.spec.containers[_]
          not containers.securityContext.runAsNonRoot
      }
      PodSetrunAsNonRoot(resource) {
          not resource.Object.spec.securityContext.runAsNonRoot
          containers := resource.Object.spec.containers[_]
          containers.securityContext.runAsNonRoot == false
      }
      PodSetrunAsNonRoot(resource) {
          resource.Object.spec.securityContext.runAsNonRoot = false
          containers := resource.Object.spec.containers[_]
          containers.securityContext.runAsNonRoot == false
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
          workloadsType[type]
          level := "warning"

          workloadsSetrunAsNonRoot(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NotRunAsNonRoot"
          }
      }

      workloadsSetrunAsNonRoot(resource) {
          not resource.Object.spec.securityContext.runAsNonRoot
          containers := resource.Object.spec.template.spec.containers[_]
          not containers.securityContext.runAsNonRoot
      }
      workloadsSetrunAsNonRoot(resource) {
          resource.Object.spec.securityContext.runAsNonRoot == false
          containers := resource.Object.spec.template.spec.containers[_]
          not containers.securityContext.runAsNonRoot
      }
      workloadsSetrunAsNonRoot(resource) {
          not resource.Object.spec.securityContext.runAsNonRoot
          containers := resource.Object.spec.template.spec.containers[_]
          containers.securityContext.runAsNonRoot == false
      }
      workloadsSetrunAsNonRoot(resource) {
          resource.Object.spec.securityContext.runAsNonRoot = false
          containers := resource.Object.spec.template.spec.containers[_]
          containers.securityContext.runAsNonRoot == false
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "CronJob"
          level := "warning"

          CronJobSetrunAsNonRoot(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NotRunAsNonRoot"
          }
      }

      CronJobSetrunAsNonRoot(resource) {
          not resource.Object.spec.securityContext.runAsNonRoot
          containers := resource.spec.jobTemplate.spec.template.spec.containers[_]
          not containers.securityContext.runAsNonRoot
      }
      CronJobSetrunAsNonRoot(resource) {
          resource.Object.spec.securityContext.runAsNonRoot == false
          containers := resource.spec.jobTemplate.spec.template.spec.containers[_]
          not containers.securityContext.runAsNonRoot
      }
      CronJobSetrunAsNonRoot(resource) {
          not resource.Object.spec.securityContext.runAsNonRoot
          containers := resource.Object.spec.jobTemplate.spec.template.spec.containers[_]
          containers.securityContext.runAsNonRoot == false
      }
      CronJobSetrunAsNonRoot(resource) {
          resource.Object.spec.securityContext.runAsNonRoot = false
          containers := resource.Object.spec.jobTemplate.spec.template.spec.containers[_]
          containers.securityContext.runAsNonRoot == false
      }
    ruleName: runAsNonRootRule
    tags:
    - kubeeye_workloads_rego
