---
apiVersion: kubeeye.kubesphere.io/v1alpha2
kind: InspectRule
metadata:
  name: filter-system-log
  labels:
    kubeeye.kubesphere.io/rule-group: inspectrule-sample
spec:
  fileFilter:
    - name: systemLog
      path: /var/log/syslog
      rule: error
  opas:
    - module: kubeeye_workloads_rego
      name: AbnormalPodStatus
      rule: |-
        package kubeeye_workloads_rego

        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "Pod"
            level := "danger"

            CheckPodPhase(resource)
            CheckPodReady(resource)
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": sprintf("Pod Status is %v", [resource.Object.status.phase])
            }
        }

        CheckPodPhase(resource) {
            resource.Object.status.phase != "Running"; resource.Object.status.phase != "Succeeded"
        }
        CheckPodReady(resource) {
            resource.Object.status.containerStatuses[_].ready != true
        }

---
apiVersion: kubeeye.kubesphere.io/v1alpha2
kind: InspectRule
metadata:
  labels:
    app.kubernetes.io/name: inspectrule
    app.kubernetes.io/instance: inspectrule-sample
    app.kubernetes.io/part-of: kubeeye
    app.kubernetes.io/managed-by: kustomize
    app.kubernetes.io/created-by: kubeeye
    kubeeye.kubesphere.io/rule-group: inspectrule-sample
  name: inspect-rule-sample
  namespace: kubeeye-system
spec:
  systemd:
    - name: docker
      rule: docker = "active"
    - name: etcd
      rule: etcd = "active"
      nodeName: master
  sysctl:
    - name: net.ipv4.ip_forward
      rule: net.ipv4.ip_forward = 1
  fileChange:
    - name: kubelet-config
      path: /var/lib/kubelet/config.yaml
  opas:
    - module: kubeeye_workloads_rego
      name: imagePullPolicyRule
      rule: |-
        package kubeeye_workloads_rego

        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "Pod"
            level := "warning"

            PodimagePullPolicyRule(resource)

            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "ImagePullPolicyNotAlways"
            }
        }

        PodimagePullPolicyRule(resource) {
            imagePullPolicy := resource.Object.spec.containers[_].imagePullPolicy
            imagePullPolicy != "Always"
        }

        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
            workloadsType[type]
            level := "warning"

            workloadsimagePullPolicyRule(resource)

            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "ImagePullPolicyNotAlways"
            }
        }

        workloadsimagePullPolicyRule(resource) {
            imagePullPolicy := resource.Object.spec.template.spec.containers[_].imagePullPolicy
            imagePullPolicy != "Always"
        }

        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "CronJob"
            level := "warning"

            CronJobimagePullPolicyRule(resource)

            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "ImagePullPolicyNotAlways"
            }
        }

        CronJobimagePullPolicyRule(resource) {
            imagePullPolicy := resource.Object.spec.jobTemplate.spec.template.spec.containers[_].imagePullPolicy
            imagePullPolicy != "Always"
        }

---
apiVersion: kubeeye.kubesphere.io/v1alpha2
kind: InspectRule
metadata:
  creationTimestamp: null
  labels:
    app.kubernetes.io/created-by: kubeeye
    app.kubernetes.io/instance: inspectrules-sample
    app.kubernetes.io/managed-by: kustomize
    app.kubernetes.io/name: inspectrules
    app.kubernetes.io/part-of: kubeeye
    kubeeye.kubesphere.io/rule-group: kubeeye_events_rego
  name: kubeeye-inspectrules0-1680158867
  namespace: kubeeye-system
spec:
  opas:
    - module: kubeeye_events_rego
      name: ExceptionEventsRule
      rule: |-
        package kubeeye_events_rego
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "Event"
            level := "warning"
            Message := resource.Object.reason
            Reason := resource.Object.message
        
            resource.Object.type != "Normal"
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": sprintf("%v", [Message]),
                "Reason": sprintf("%v", [Reason]),
            }
        }


---
apiVersion: kubeeye.kubesphere.io/v1alpha2
kind: InspectRule
metadata:
  creationTimestamp: null
  labels:
    app.kubernetes.io/created-by: kubeeye
    app.kubernetes.io/instance: inspectrules-sample
    app.kubernetes.io/managed-by: kustomize
    app.kubernetes.io/name: inspectrules
    app.kubernetes.io/part-of: kubeeye
    kubeeye.kubesphere.io/rule-group: kubeeye_nodes_rego
  name: kubeeye-inspectrules1-1680158867
  namespace: kubeeye-system
spec:
  opas:
    - module: kubeeye_nodes_rego
      name: FalseNodeConditionsRule
      rule: |-
        package kubeeye_nodes_rego
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            type == "Node"
            level := "warning"
        
            resource.Object.status.conditions[i].status == "False"
        
            contains(resource.Object.status.conditions[i].message, "has")
            not contains(resource.Object.status.conditions[i].message, "has no")
            Message := replace(resource.Object.status.conditions[i].message,"has", "has no")
            contains(resource.Object.status.conditions[i].reason, "Has")
            not contains(resource.Object.status.conditions[i].reason, "HasNo")
            Reason := replace(resource.Object.status.conditions[i].reason,"Has", "HasNo")
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": sprintf("%v", [Reason]),
                "Reason": sprintf("%v", [Message]),
            }
        }
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            type == "Node"
            level := "warning"
        
            resource.Object.status.conditions[i].status == "False"
        
            contains(resource.Object.status.conditions[i].message, "has no")
            Message := replace(resource.Object.status.conditions[i].message,"has no", "has")
            contains(resource.Object.status.conditions[i].reason, "HasNo")
            Reason := replace(resource.Object.status.conditions[i].reason,"HasNo", "Has")
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": sprintf("%v", [Reason]),
                "Reason": sprintf("%v", [Message]),
            }
        }

---
apiVersion: kubeeye.kubesphere.io/v1alpha2
kind: InspectRule
metadata:
  creationTimestamp: null
  labels:
    app.kubernetes.io/created-by: kubeeye
    app.kubernetes.io/instance: inspectrules-sample
    app.kubernetes.io/managed-by: kustomize
    app.kubernetes.io/name: inspectrules
    app.kubernetes.io/part-of: kubeeye
    kubeeye.kubesphere.io/rule-group: kubeeye_RBAC_rego
  name: kubeeye-inspectrules2-1680158867
  namespace: kubeeye-system
spec:
  opas:
    - module: kubeeye_RBAC_rego
      name: canModifyWorkloadsRoleRule
      rule: |-
        package kubeeye_RBAC_rego
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "Role"
            level := "warning"
        
            isNotDefaultRBAC(resource)
            canModifyPodResource(resource)
            haveModifyPodResourceVerb(resource)
        
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "CanModifyWorkloads"
            }
        }
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            type == "ClusterRole"
            level := "warning"
        
            isNotDefaultRBAC(resource)
            canModifyPodResource(resource)
            haveModifyPodResourceVerb(resource)
        
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "CanModifyWorkloads"
            }
        }
        
        isNotDefaultRBAC(resource) {
            not resource.Object.metadata.labels["kubernetes.io/bootstrapping"] == "rbac-defaults"
        }
        
        canModifyPodResource(resource){
            resource.Object.rules[_].resources[_] == "pods"
        }
        
        canModifyPodResource(resource){
            resource.Object.rules[_].resources[_] == "deployments"
        }
        
        canModifyPodResource(resource){
            resource.Object.rules[_].resources[_] == "daemonsets"
        }
        
        canModifyPodResource(resource){
            resource.Object.rules[_].resources[_] == "replicasets"
        }
        
        canModifyPodResource(resource){
            resource.Object.rules[_].resources[_] == "statefulsets"
        }
        
        canModifyPodResource(resource){
            resource.Object.rules[_].resources[_] == "jobs"
        }
        
        canModifyPodResource(resource){
            resource.Object.rules[_].resources[_] == "cronjobs"
        }
        
        canModifyPodResource(resource){
            resource.Object.rules[_].resources[_] == "replicationcontrollers"
        }
        
        canModifyPodResource(resource){
            resource.Object.rules[_].resources[_] == "*"
        }
        
        haveModifyPodResourceVerb(resource){
            resource.Object.rules[_].verbs[_] == "create"
        }
        
        haveModifyPodResourceVerb(resource){
            resource.Object.rules[_].verbs[_] == "update"
        }
        
        haveModifyPodResourceVerb(resource){
            resource.Object.rules[_].verbs[_] == "patch"
        }
        
        haveModifyPodResourceVerb(resource){
            resource.Object.rules[_].verbs[_] == "delete"
        }
        
        haveModifyPodResourceVerb(resource){
            resource.Object.rules[_].verbs[_] == "deletecollection"
        }
        
        haveModifyPodResourceVerb(resource){
            resource.Object.rules[_].verbs[_] == "*"
        }
    - module: kubeeye_RBAC_rego
      name: canModifyResourcesRoleRule
      rule: |-
        package kubeeye_RBAC_rego
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "Role"
            level := "warning"
        
            isNotDefaultRBAC(resource)
            canModifyResources(resource)
            haveModifyResourcesVerb(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "CanDeleteResources"
            }
        }
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            type == "ClusterRole"
            level := "warning"
        
            isNotDefaultRBAC(resource)
            canModifyResources(resource)
            haveModifyResourcesVerb(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "CanDeleteResources"
            }
        }
        
        isNotDefaultRBAC(resource) {
            not resource.Object.metadata.labels["kubernetes.io/bootstrapping"] == "rbac-defaults"
        }
        
        canModifyResources(resource){
            resource.Object.rules[_].resources[_] == "secrets"
        }
        
        canModifyResources(resource){
            resource.Object.rules[_].resources[_] == "configmaps"
        }
        
        canModifyResources(resource){
            resource.Object.rules[_].resources[_] == "persistentvolumeclaims"
        }
        
        canModifyResources(resource){
            resource.Object.rules[_].resources[_] == "horizontalpodautoscalers"
        }
        
        canModifyResources(resource){
            resource.Object.rules[_].resources[_] == "events"
        }
        
        canModifyResources(resource){
            resource.Object.rules[_].resources[_] == "roles"
        }
        
        canModifyResources(resource){
            resource.Object.rules[_].resources[_] == "clusterroles"
        }
        
        canModifyResources(resource){
            resource.Object.rules[_].resources[_] == "users"
        }
        
        canModifyResources(resource){
            resource.Object.rules[_].resources[_] == "groups"
        }
        
        canModifyResources(resource){
            resource.Object.rules[_].resources[_] == "serviceaccounts"
        }
        
        
        canModifyResources(resource){
            resource.Object.rules[_].resources[_] == "services"
        }
        
        canModifyResources(resource){
            resource.Object.rules[_].resources[_] == "ingresses"
        }
        
        canModifyResources(resource){
            resource.Object.rules[_].resources[_] == "endpoints"
        }
        
        canModifyResources(resource){
            resource.Object.rules[_].resources[_] == "networkpolicies"
        }
        
        canModifyResources(resource){
            resource.Object.rules[_].resources[_] == "certificates"
        }
        
        canModifyResources(resource){
            resource.Object.rules[_].resources[_] == "certificaterequests"
        }
        
        canModifyResources(resource){
            resource.Object.rules[_].resources[_] == "issuers"
        }
        
        canModifyResources(resource){
            resource.Object.rules[_].resources[_] == "*"
        }
        
        haveModifyResourcesVerb(resource){
            resource.Object.rules[_].verbs[_] == "create"
        }
        
        haveModifyResourcesVerb(resource){
            resource.Object.rules[_].verbs[_] == "update"
        }
        
        haveModifyResourcesVerb(resource){
            resource.Object.rules[_].verbs[_] == "patch"
        }
        
        haveModifyResourcesVerb(resource){
            resource.Object.rules[_].verbs[_] == "delete"
        }
        
        haveModifyResourcesVerb(resource){
            resource.Object.rules[_].verbs[_] == "deletecollection"
        }
        
        haveModifyResourcesVerb(resource){
            resource.Object.rules[_].verbs[_] == "*"
        }
    - module: kubeeye_RBAC_rego
      name: canImpersonateUserRoleRule
      rule: |-
        package kubeeye_RBAC_rego
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "Role"
            level := "warning"
        
            isNotDefaultRBAC(resource)
            canImpersonateUserResource(resource)
            haveImpersonateUserResourceVerb(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "CanImpersonateUser"
            }
        }
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            type == "ClusterRole"
            level := "warning"
        
            isNotDefaultRBAC(resource)
            canImpersonateUserResource(resource)
            haveImpersonateUserResourceVerb(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "CanImpersonateUser"
            }
        }
        
        isNotDefaultRBAC(resource) {
            not resource.Object.metadata.labels["kubernetes.io/bootstrapping"] == "rbac-defaults"
        }
        
        canImpersonateUserResource(resource){
            resource.Object.rules[_].resources[_] == "users"
        }
        
        canImpersonateUserResource(resource){
            resource.Object.rules[_].resources[_] == "groups"
        }
        
        canImpersonateUserResource(resource){
            resource.Object.rules[_].resources[_] == "serviceaccounts"
        }
        
        canImpersonateUserResource(resource){
            resource.Object.rules[_].resources[_] == "*"
        }
        
        haveImpersonateUserResourceVerb(resource){
            resource.Object.rules[_].verbs[_] == "impersonate"
        }
        
        haveImpersonateUserResourceVerb(resource){
            resource.Object.rules[_].verbs[_] == "*"
        }

---
apiVersion: kubeeye.kubesphere.io/v1alpha2
kind: InspectRule
metadata:
  creationTimestamp: null
  labels:
    app.kubernetes.io/created-by: kubeeye
    app.kubernetes.io/instance: inspectrules-sample
    app.kubernetes.io/managed-by: kustomize
    app.kubernetes.io/name: inspectrules
    app.kubernetes.io/part-of: kubeeye
    kubeeye.kubesphere.io/rule-group: inspectrule-sample
  name: kubeeye-inspectrules3-1680158867
  namespace: kubeeye-system
spec:
  opas:
    - module: kubeeye_workloads_rego
      name: runAsNonRootRule
      rule: |-
        package kubeeye_workloads_rego
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "Pod"
            level := "warning"
        
            PodSetrunAsNonRoot(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "NotRunAsNonRoot"
            }
        }
        
        PodSetrunAsNonRoot(resource) {
            not resource.Object.spec.securityContext.runAsNonRoot
            containers := resource.Object.spec.containers[_]
            not containers.securityContext.runAsNonRoot
        }
        PodSetrunAsNonRoot(resource) {
            resource.Object.spec.securityContext.runAsNonRoot == false
            containers := resource.Object.spec.containers[_]
            not containers.securityContext.runAsNonRoot
        }
        PodSetrunAsNonRoot(resource) {
            not resource.Object.spec.securityContext.runAsNonRoot
            containers := resource.Object.spec.containers[_]
            containers.securityContext.runAsNonRoot == false
        }
        PodSetrunAsNonRoot(resource) {
            resource.Object.spec.securityContext.runAsNonRoot = false
            containers := resource.Object.spec.containers[_]
            containers.securityContext.runAsNonRoot == false
        }
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
            workloadsType[type]
            level := "warning"
        
            workloadsSetrunAsNonRoot(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "NotRunAsNonRoot"
            }
        }
        
        workloadsSetrunAsNonRoot(resource) {
            not resource.Object.spec.securityContext.runAsNonRoot
            containers := resource.Object.spec.template.spec.containers[_]
            not containers.securityContext.runAsNonRoot
        }
        workloadsSetrunAsNonRoot(resource) {
            resource.Object.spec.securityContext.runAsNonRoot == false
            containers := resource.Object.spec.template.spec.containers[_]
            not containers.securityContext.runAsNonRoot
        }
        workloadsSetrunAsNonRoot(resource) {
            not resource.Object.spec.securityContext.runAsNonRoot
            containers := resource.Object.spec.template.spec.containers[_]
            containers.securityContext.runAsNonRoot == false
        }
        workloadsSetrunAsNonRoot(resource) {
            resource.Object.spec.securityContext.runAsNonRoot = false
            containers := resource.Object.spec.template.spec.containers[_]
            containers.securityContext.runAsNonRoot == false
        }
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "CronJob"
            level := "warning"
        
            CronJobSetrunAsNonRoot(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "NotRunAsNonRoot"
            }
        }
        
        CronJobSetrunAsNonRoot(resource) {
            not resource.Object.spec.securityContext.runAsNonRoot
            containers := resource.spec.jobTemplate.spec.template.spec.containers[_]
            not containers.securityContext.runAsNonRoot
        }
        CronJobSetrunAsNonRoot(resource) {
            resource.Object.spec.securityContext.runAsNonRoot == false
            containers := resource.spec.jobTemplate.spec.template.spec.containers[_]
            not containers.securityContext.runAsNonRoot
        }
        CronJobSetrunAsNonRoot(resource) {
            not resource.Object.spec.securityContext.runAsNonRoot
            containers := resource.Object.spec.jobTemplate.spec.template.spec.containers[_]
            containers.securityContext.runAsNonRoot == false
        }
        CronJobSetrunAsNonRoot(resource) {
            resource.Object.spec.securityContext.runAsNonRoot = false
            containers := resource.Object.spec.jobTemplate.spec.template.spec.containers[_]
            containers.securityContext.runAsNonRoot == false
        }
    - module: kubeeye_workloads_rego
      name: readinessProbeRule
      rule: |-
        package kubeeye_workloads_rego
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "Pod"
            level := "warning"
        
            PodSetreadinessProbe(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "NoReadinessProbe"
            }
        }
        
        PodSetreadinessProbe(resource) {
            containers := resource.Object.spec.containers[_]
            not containers.readinessProbe
        }
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
            workloadsType[type]
            level := "warning"
        
            workloadsSetreadinessProbe(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "NoReadinessProbe"
            }
        }
        
        workloadsSetreadinessProbe(resource) {
            containers := resource.Object.spec.template.spec.containers[_]
            not containers.readinessProbe
        }
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "CronJob"
            level := "warning"
        
            CronjobSetreadinessProbe(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "NoReadinessProbe"
            }
        }
        
        CronjobSetreadinessProbe(resource) {
            containers := resource.Object.spec.jobTemplate.spec.template.spec.containers[_]
            not containers.readinessProbe
        }
    - module: kubeeye_workloads_rego
      name: readOnlyRootFilesystemRule
      rule: |-
        package kubeeye_workloads_rego
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "Pod"
            level := "warning"
        
            PodSetreadOnlyRootFilesystem(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "NotReadOnlyRootFilesystem"
            }
        }
        
        PodSetreadOnlyRootFilesystem(resource) {
            not resource.Object.spec.securityContext.readOnlyRootFilesystem == true
            containers := resource.Object.spec.containers[_]
            not containers.securityContext.readOnlyRootFilesystem == true
        }
        PodSetreadOnlyRootFilesystem(resource) {
            not resource.Object.spec.securityContext.readOnlyRootFilesystem
            containers := resource.Object.spec.containers[_]
            not containers.securityContext.readOnlyRootFilesystem == true
        }
        PodSetreadOnlyRootFilesystem(resource) {
            not resource.Object.spec.securityContext.readOnlyRootFilesystem == true
            containers := resource.Object.spec.containers[_]
            not containers.securityContext.readOnlyRootFilesystem
        }
        PodSetreadOnlyRootFilesystem(resource) {
            not resource.Object.spec.securityContext.readOnlyRootFilesystem
            containers := resource.Object.spec.containers[_]
            not containers.securityContext.readOnlyRootFilesystem
        }
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
            workloadsType[type]
            level := "warning"
        
            workloadsSetreadOnlyRootFilesystem(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "NotReadOnlyRootFilesystem"
            }
        }
        
        workloadsSetreadOnlyRootFilesystem(resource) {
            not resource.Object.spec.securityContext.readOnlyRootFilesystem == true
            containers := resource.Object.spec.template.spec.containers[_]
            not containers.securityContext.readOnlyRootFilesystem == true
        }
        workloadsSetreadOnlyRootFilesystem(resource) {
            not resource.Object.spec.securityContext.readOnlyRootFilesystem
            containers := resource.Object.spec.template.spec.containers[_]
            not containers.securityContext.readOnlyRootFilesystem == true
        }
        workloadsSetreadOnlyRootFilesystem(resource) {
            not resource.Object.spec.securityContext.readOnlyRootFilesystem == true
            containers := resource.Object.spec.template.spec.containers[_]
            not containers.securityContext.readOnlyRootFilesystem
        }
        workloadsSetreadOnlyRootFilesystem(resource) {
            not resource.Object.spec.securityContext.readOnlyRootFilesystem
            containers := resource.Object.spec.template.spec.containers[_]
            not containers.securityContext.readOnlyRootFilesystem
        }
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "CronJob"
            level := "warning"
        
            CronJobSetreadOnlyRootFilesystem(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "NotReadOnlyRootFilesystem"
            }
        }
        
        CronJobSetreadOnlyRootFilesystem(resource) {
            not resource.Object.spec.securityContext.readOnlyRootFilesystem == true
            containers := resource.Object.spec.jobTemplate.spec.template.spec.containers[_]
            not containers.securityContext.readOnlyRootFilesystem == true
        }
        CronJobSetreadOnlyRootFilesystem(resource) {
            not resource.Object.spec.securityContext.readOnlyRootFilesystem
            containers := resource.Object.spec.jobTemplate.spec.template.spec.containers[_]
            not containers.securityContext.readOnlyRootFilesystem == true
        }
        CronJobSetreadOnlyRootFilesystem(resource) {
            not resource.Object.spec.securityContext.readOnlyRootFilesystem == true
            containers := resource.Object.spec.jobTemplate.spec.template.spec.containers[_]
            not containers.securityContext.readOnlyRootFilesystem
        }
        CronJobSetreadOnlyRootFilesystem(resource) {
            not resource.Object.spec.securityContext.readOnlyRootFilesystem
            containers := resource.Object.spec.jobTemplate.spec.template.spec.containers[_]
            not containers.securityContext.readOnlyRootFilesystem
        }
    - module: kubeeye_workloads_rego
      name: privilegedRule
      rule: |-
        package kubeeye_workloads_rego
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "Pod"
            level := "danger"
        
            PodSetPrivilegedRule(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "PrivilegedAllowed"
            }
        }
        
        PodSetPrivilegedRule(resource) {
            resource.Object.spec.containers[_].securityContext.privileged == true
        }
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
            workloadsType[type]
            level := "danger"
        
            workloadsSetPrivilegedRule(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "PrivilegedAllowed"
            }
        }
        
        workloadsSetPrivilegedRule(resource) {
            resource.Object.spec.template.spec.containers[_].securityContext.privileged == true
        }
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "CronJob"
            level := "danger"
        
            CronJobSetPrivilegedRule(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "PrivilegedAllowed"
            }
        }
        
        CronJobSetPrivilegedRule(resource) {
            resource.Object.spec.jobTemplate.spec.template.spec.containers[_].securityContext.privileged == true
        }
    - module: kubeeye_workloads_rego
      name: memoryRequestsRule
      rule: |-
        package kubeeye_workloads_rego
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "Pod"
            level := "danger"
        
            PodSetMemoryRequests(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "NoMemoryRequests"
            }
        }
        
        PodSetMemoryRequests(resource) {
            containers := resource.Object.spec.containers[_]
            not containers.resources.requests.memory
        }
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
            workloadsType[type]
            level := "danger"
        
            workloadsSetMemoryRequests(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "NoMemoryRequests"
            }
        }
        
        workloadsSetMemoryRequests(resource) {
            containers := resource.Object.spec.template.spec.containers[_]
            not containers.resources.requests.memory
        }
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "CronJob"
            level := "danger"
        
            CronjobSetMemoryRequests(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "NoMemoryRequests"
            }
        }
        
        CronjobSetMemoryRequests(resource) {
            containers := resource.Object.spec.jobTemplate.spec.template.spec.containers[_]
            not containers.resources.requests.memory
        }
    - module: kubeeye_workloads_rego
      name: memoryLimitsRule
      rule: |-
        package kubeeye_workloads_rego
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "Pod"
            level := "danger"
        
            PodSetMemoryLimits(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "NoMemoryLimits"
            }
        }
        
        PodSetMemoryLimits(resource) {
            containers := resource.Object.spec.containers[_]
            not containers.resources.limits.memory
        }
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
            workloadsType[type]
            level := "danger"
        
            workloadsSetMemoryLimits(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "NoMemoryLimits"
            }
        }
        
        workloadsSetMemoryLimits(resource) {
            containers := resource.Object.spec.template.spec.containers[_]
            not containers.resources.limits.memory
        }
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "CronJob"
            level := "danger"
        
            CronjobSetMemoryLimits(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "NoMemoryLimits"
            }
        }
        
        CronjobSetMemoryLimits(resource) {
            containers := resource.Object.spec.jobTemplate.spec.template.spec.containers[_]
            not containers.resources.limits.memory
        }
    - module: kubeeye_workloads_rego
      name: livenessProbeRule
      rule: |-
        package kubeeye_workloads_rego
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "Pod"
            level := "warning"
        
            PodSetlivenessProbe(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "NoLivenessProbe"
            }
        }
        
        PodSetlivenessProbe(resource) {
            containers := resource.Object.spec.containers[_]
            not containers.livenessProbe
        }
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
            workloadsType[type]
            level := "warning"
        
            workloadsSetlivenessProbe(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "NoLivenessProbe"
            }
        }
        
        workloadsSetlivenessProbe(resource) {
            containers := resource.Object.spec.template.spec.containers[_]
            not containers.livenessProbe
        }
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "CronJob"
            level := "warning"
        
            CronjobSetlivenessProbe(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "NoLivenessProbe"
            }
        }
        
        CronjobSetlivenessProbe(resource) {
            containers := resource.Object.spec.jobTemplate.spec.template.spec.containers[_]
            not containers.livenessProbe
        }
    - module: kubeeye_workloads_rego
      name: insecureCapabilitiesRule
      rule: |-
        package kubeeye_workloads_rego
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "Pod"
            level := "warning"
        
            PodSetInsecureCapabilities(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "InsecureCapabilities"
            }
        }
        
        PodSetInsecureCapabilities(resource) {
            insecureCapabilities := ["CHOWN", "DAC_OVERRIDE", "FSETID", "FOWNER", "MKNOD", "NET_RAW", "SETGID", "SETUID", "SETFCAP", "NET_BIND_SERVICE","SYS_CHROOT","KILL","AUDIT_WRITE"]
            containers := resource.Object.spec.containers[_]
            insecureCapabilities[_] == containers.securityContext.capabilities.add[_]
        } else {
            insecureCapabilities := ["CHOWN", "DAC_OVERRIDE", "FSETID", "FOWNER", "MKNOD", "NET_RAW", "SETGID", "SETUID", "SETFCAP", "NET_BIND_SERVICE","SYS_CHROOT","KILL","AUDIT_WRITE"]
            insecureCapabilities[_] == resource.Object.spec.securityContext.capabilities.add[_]
        }
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
            workloadsType[type]
            level := "warning"
        
            WorkloadsSetInsecureCapabilities(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "InsecureCapabilities"
            }
        }
        
        WorkloadsSetInsecureCapabilities(resource) {
            insecureCapabilities := ["CHOWN", "DAC_OVERRIDE", "FSETID", "FOWNER", "MKNOD", "NET_RAW", "SETGID", "SETUID", "SETFCAP", "NET_BIND_SERVICE","SYS_CHROOT","KILL","AUDIT_WRITE"]
            containers := resource.Object.spec.template.spec.containers[_]
            insecureCapabilities[_] == containers.securityContext.capabilities.add[_]
        } else {
            insecureCapabilities := ["CHOWN", "DAC_OVERRIDE", "FSETID", "FOWNER", "MKNOD", "NET_RAW", "SETGID", "SETUID", "SETFCAP", "NET_BIND_SERVICE","SYS_CHROOT","KILL","AUDIT_WRITE"]
            insecureCapabilities[_] == resource.Object.spec.template.spec.securityContext.capabilities.add[_]
        }
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "CronJob"
            level := "warning"
        
            CronjobSetInsecureCapabilities(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "InsecureCapabilities"
            }
        }
        
        CronjobSetInsecureCapabilities(resource) {
            insecureCapabilities := ["CHOWN", "DAC_OVERRIDE", "FSETID", "FOWNER", "MKNOD", "NET_RAW", "SETGID", "SETUID", "SETFCAP", "NET_BIND_SERVICE","SYS_CHROOT","KILL","AUDIT_WRITE"]
            containers := resource.Object.spec.jobTemplate.spec.template.spec.containers[_]
            insecureCapabilities[_] == containers.securityContext.capabilities.add[_]
        } else {
            insecureCapabilities := ["CHOWN", "DAC_OVERRIDE", "FSETID", "FOWNER", "MKNOD", "NET_RAW", "SETGID", "SETUID", "SETFCAP", "NET_BIND_SERVICE","SYS_CHROOT","KILL","AUDIT_WRITE"]
            insecureCapabilities[_] == resource.Object.spec.jobTemplate.spec.template.spec.securityContext.capabilities.add[_]
        }
    - module: kubeeye_workloads_rego
      name: imageTagRule
      rule: |-
        package kubeeye_workloads_rego
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "Pod"
            level := "warning"
        
            PodImageTagRule(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "ImageTagIsLatest"
            }
        }
        
        PodImageTagRule(resource) {
            regex.match("^.+:latest$", input.Object.spec.containers[_].image)
        }
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
            workloadsType[type]
            level := "warning"
        
            workloadsImageTagRule(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "ImageTagIsLatest"
            }
        }
        
        workloadsImageTagRule(resource) {
            regex.match("^.+:latest$", resource.Object.spec.template.spec.containers[_].image)
        }
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "CronJob"
            level := "warning"
        
            CronJobImageTagRule(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "ImageTagIsLatest"
            }
        }
        
        CronJobImageTagRule(resource) {
            regex.match("^.+:latest$", resource.Object.spec.jobTemplate.spec.template.spec.containers[_].image)
        }
    - module: kubeeye_workloads_rego
      name: imageTagMissingRule
      rule: |-
        package kubeeye_workloads_rego
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "Pod"
            level := "danger"
        
            not PodImageTagRule(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "ImageTagMiss"
            }
        }
        
        PodImageTagRule(resource) {
            regex.match("^.+:.+$", input.Object.spec.containers[_].image)
        }
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
            workloadsType[type]
            level := "danger"
        
            not workloadsImageTagRule(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "ImageTagMiss"
            }
        }
        
        workloadsImageTagRule(resource) {
            regex.match("^.+:.+$", resource.Object.spec.template.spec.containers[_].image)
        }
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "CronJob"
            level := "danger"
        
            not CronJobImageTagRule(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "ImageTagMiss"
            }
        }
        
        CronJobImageTagRule(resource) {
            regex.match("^.+:.+", resource.Object.spec.jobTemplate.spec.template.spec.containers[_].image)
        }
    - module: kubeeye_workloads_rego
      name: imagePullPolicyRule
      rule: |-
        package kubeeye_workloads_rego
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "Pod"
            level := "warning"
        
            PodimagePullPolicyRule(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "ImagePullPolicyNotAlways"
            }
        }
        
        PodimagePullPolicyRule(resource) {
            imagePullPolicy := resource.Object.spec.containers[_].imagePullPolicy
            imagePullPolicy != "Always"
        }
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
            workloadsType[type]
            level := "warning"
        
            workloadsimagePullPolicyRule(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "ImagePullPolicyNotAlways"
            }
        }
        
        workloadsimagePullPolicyRule(resource) {
            imagePullPolicy := resource.Object.spec.template.spec.containers[_].imagePullPolicy
            imagePullPolicy != "Always"
        }
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "CronJob"
            level := "warning"
        
            CronJobimagePullPolicyRule(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "ImagePullPolicyNotAlways"
            }
        }
        
        CronJobimagePullPolicyRule(resource) {
            imagePullPolicy := resource.Object.spec.jobTemplate.spec.template.spec.containers[_].imagePullPolicy
            imagePullPolicy != "Always"
        }
    - module: kubeeye_workloads_rego
      name: hostPortRule
      rule: |-
        package kubeeye_workloads_rego
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "Pod"
            level := "danger"
        
            PodSethostPort(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "HostPortAllowed"
            }
        }
        
        PodSethostPort(resource) {
            resource.Object.spec.containers[_].ports[_].hostPort
        }
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
            workloadsType[type]
            level := "danger"
        
            workloadsSethostPort(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "HostPortAllowed"
            }
        }
        
        workloadsSethostPort(resource) {
            resource.Object.spec.template.spec.containers[_].ports[_].hostPort
        }
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "CronJob"
            level := "danger"
        
            CronJobSethostPort(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "HostPortAllowed"
            }
        }
        
        CronJobSethostPort(resource) {
            resource.Object.spec.jobTemplate.spec.template.spec.containers[_].ports[_].hostPort
        }
    - module: kubeeye_workloads_rego
      name: hostPIDRule
      rule: |-
        package kubeeye_workloads_rego
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "Pod"
            level := "danger"
        
            PodSethostPID(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "HostPIDAllowed"
            }
        }
        
        PodSethostPID(resource) {
            resource.Object.spec.hostPID == true
        }
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
            workloadsType[type]
            level := "danger"
        
            workloadsSethostPID(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "HostPIDAllowed"
            }
        }
        
        workloadsSethostPID(resource) {
            resource.Object.spec.template.spec.hostPID == true
        }
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "CronJob"
            level := "danger"
        
            CronJobSethostPID(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "HostPIDAllowed"
            }
        }
        
        CronJobSethostPID(resource) {
            resource.Object.spec.jobTemplate.spec.template.spec.hostPID == true
        }
    - module: kubeeye_workloads_rego
      name: hostNetworkRule
      rule: |-
        package kubeeye_workloads_rego
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "Pod"
            level := "danger"
        
            PodSethostNetwork(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "HostNetworkAllowed"
            }
        }
        
        PodSethostNetwork(resource) {
            resource.Object.spec.hostNetwork == true
        }
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
            workloadsType[type]
            level := "danger"
        
            workloadsSethostNetwork(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "HostNetworkAllowed"
            }
        }
        
        workloadsSethostNetwork(resource) {
            resource.Object.spec.template.spec.hostNetwork == true
        }
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "CronJob"
            level := "danger"
        
            CronJobSethostNetwork(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "HostNetworkAllowed"
            }
        }
        
        CronJobSethostNetwork(resource) {
            resource.Object.spec.jobTemplate.spec.template.spec.hostNetwork == true
        }
    - module: kubeeye_workloads_rego
      name: hostIPCRule
      rule: |-
        package kubeeye_workloads_rego
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "Pod"
            level := "danger"
        
            PodSethostIPC(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "HostIPCAllowed"
            }
        }
        
        PodSethostIPC(resource) {
            resource.Object.spec.hostIPC == true
        }
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
            workloadsType[type]
            level := "danger"
        
            workloadsSethostIPC(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "HostIPCAllowed"
            }
        }
        
        workloadsSethostIPC(resource) {
            resource.Object.spec.template.spec.hostIPC == true
        }
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "CronJob"
            level := "danger"
        
            CronJobSethostIPC(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "HostIPCAllowed"
            }
        }
        
        CronJobSethostIPC(resource) {
            resource.Object.spec.jobTemplate.spec.template.spec.hostIPC == true
        }
    - module: kubeeye_workloads_rego
      name: highRiskCapabilitiesRule
      rule: |-
        package kubeeye_workloads_rego
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "Pod"
            level := "danger"
        
            PodSetHighRiskCapabilities(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "HighRiskCapabilities"
            }
        }
        
        PodSetHighRiskCapabilities(resource) {
            HighRiskCapabilities := ["NET_ADMIN", "SYS_ADMIN", "ALL"]
            containers := resource.Object.spec.containers[_]
            HighRiskCapabilities[_] == containers.securityContext.capabilities.add[_]
        } else {
            HighRiskCapabilities := ["NET_ADMIN", "SYS_ADMIN", "ALL"]
            HighRiskCapabilities[_] == resource.Object.spec.securityContext.capabilities.add[_]
        }
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
            workloadsType[type]
            level := "danger"
        
            WorkloadsSetHighRiskCapabilities(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "HighRiskCapabilities"
            }
        }
        
        WorkloadsSetHighRiskCapabilities(resource) {
            HighRiskCapabilities := ["NET_ADMIN", "SYS_ADMIN", "ALL"]
            containers := resource.Object.spec.template.spec.containers[_]
            HighRiskCapabilities[_] == containers.securityContext.capabilities.add[_]
        } else {
            HighRiskCapabilities := ["NET_ADMIN", "SYS_ADMIN", "ALL"]
            HighRiskCapabilities[_] == resource.Object.spec.template.spec.securityContext.capabilities.add[_]
        }
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "CronJob"
            level := "danger"
        
            CronjobSetHighRiskCapabilities(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "HighRiskCapabilities"
            }
        }
        
        CronjobSetHighRiskCapabilities(resource) {
            HighRiskCapabilities := ["NET_ADMIN", "SYS_ADMIN", "ALL"]
            containers := resource.Object.spec.jobTemplate.spec.template.spec.containers[_]
            HighRiskCapabilities[_] == containers.securityContext.capabilities.add[_]
        } else {
            HighRiskCapabilities := ["NET_ADMIN", "SYS_ADMIN", "ALL"]
            HighRiskCapabilities[_] == resource.Object.spec.jobTemplate.spec.template.spec.securityContext.capabilities.add[_]
        }
    - module: kubeeye_workloads_rego
      name: allowPrivilegeEscalationRule
      rule: |-
        package kubeeye_workloads_rego
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "Pod"
            level := "danger"
        
            PodSetallowPrivilegeEscalation(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "PrivilegeEscalationAllowed"
            }
        }
        
        PodSetallowPrivilegeEscalation(resource) {
            resource.Object.spec.securityContext.allowPrivilegeEscalation == true
        } else {
            resource.Object.spec.containers[_].securityContext.allowPrivilegeEscalation == true
        }
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
            workloadsType[type]
            level := "danger"
        
            DownloadsSetallowPrivilegeEscalation(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "PrivilegeEscalationAllowed"
            }
        }
        
        DownloadsSetallowPrivilegeEscalation(resource) {
            resource.Object.spec.template.spec.containers[_].securityContext.allowPrivilegeEscalation == true
        } else {
            resource.Object.spec.template.spec.securityContext.allowPrivilegeEscalation == true
        }
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "CronJob"
            level := "danger"
        
            CronjobSetallowPrivilegeEscalation(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "PrivilegeEscalationAllowed"
            }
        }
        
        CronjobSetallowPrivilegeEscalation(resource) {
            resource.Object.spec.jobTemplate.spec.template.spec.containers[_].securityContext.allowPrivilegeEscalation == true
        } else {
            resource.Object.spec.jobTemplate.spec.template.spec.securityContext.allowPrivilegeEscalation == true
        }
    - module: kubeeye_workloads_rego
      name: CPURequestsRule
      rule: |-
        package kubeeye_workloads_rego
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "Pod"
            level := "danger"
        
            PodSetCPURequests(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "NoCPURequests"
            }
        }
        
        PodSetCPURequests(resource) {
                containers := resource.Object.spec.containers[_]
                not containers.resources.requests.cpu
        }
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
            workloadsType[type]
            level := "danger"
        
            workloadsSetCPURequests(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "NoCPURequests"
            }
        }
        
        workloadsSetCPURequests(resource) {
            containers := resource.Object.spec.template.spec.containers[_]
            not containers.resources.requests.cpu
        }
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "CronJob"
            level := "danger"
        
            CronjobSetCPURequests(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "NoCPURequests"
            }
        }
        
        CronjobSetCPURequests(resource) {
            containers := resource.Object.spec.jobTemplate.spec.template.spec.containers[_]
            not containers.resources.requests.cpu
        }
    - module: kubeeye_workloads_rego
      name: CPULimitsRule
      rule: |-
        package kubeeye_workloads_rego
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "Pod"
            level := "danger"
        
            PodSetCPULimits(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "NoCPULimits"
            }
        }
        
        PodSetCPULimits(resource) {
            containers := resource.Object.spec.containers[_]
            not containers.resources.limits.cpu
        }
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
            workloadsType[type]
            level := "danger"
        
            workloadsSetCPULimits(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "NoCPULimits"
            }
        }
        
        workloadsSetCPULimits(resource) {
            containers := resource.Object.spec.template.spec.containers[_]
            not containers.resources.limits.cpu
        }
        
        deny[msg] {
            resource := input
            type := resource.Object.kind
            resourcename := resource.Object.metadata.name
            resourcenamespace := resource.Object.metadata.namespace
            type == "CronJob"
            level := "danger"
        
            CronjobSetCPULimits(resource)
        
            msg := {
                "Name": sprintf("%v", [resourcename]),
                "Namespace": sprintf("%v", [resourcenamespace]),
                "Type": sprintf("%v", [type]),
                "Level": sprintf("%v", [level]),
                "Message": "NoCPULimits"
            }
        }
        
        CronjobSetCPULimits(resource) {
            containers := resource.Object.spec.jobTemplate.spec.template.spec.containers[_]
            not containers.resources.limits.cpu
        }

---
apiVersion: kubeeye.kubesphere.io/v1alpha2
kind: InspectRule
metadata:
  labels:
    app.kubernetes.io/name: inspectrule
    app.kubernetes.io/instance: inspectrule-sample
    app.kubernetes.io/part-of: kubeeye
    app.kubernetes.io/managed-by: kustomize
    app.kubernetes.io/created-by: kubeeye
    kubeeye.kubesphere.io/rule-group: inspectrule-sample
  name: prometheus-sample
spec:
  prometheusEndpoint: http://whizard-agent-proxy.kubesphere-monitoring-system.svc.cluster.local:9090
  prometheus:
    - name: filesystem-less-20
      desc: Filesystem inode where less 20 %
      rule: (node_filesystem_files_free{fstype!="",job="node-exporter"} / node_filesystem_files{fstype!="",job="node-exporter"} * 100 < 20 and node_filesystem_readonly{fstype!="",job="node-exporter"} == 0)
    - name: NodeFilesystemSpaceFillingUp
      desc: Filesystem is predicted to run out of space within the next 24 hours.
      rule: (node_filesystem_avail_bytes{fstype!="",job="node-exporter"} / node_filesystem_size_bytes{fstype!="",job="node-exporter"} * 100 < 20 and predict_linear(node_filesystem_avail_bytes{fstype!="",job="node-exporter"}[6h], 24 * 60 * 60) < 0 and node_filesystem_readonly{fstype!="",job="node-exporter"} == 0)
    - name: NodeFilesystemFilesFillingUp
      rule: (node_filesystem_files_free{fstype!="",job="node-exporter"} / node_filesystem_files{fstype!="",job="node-exporter"} * 100 < 40 and predict_linear(node_filesystem_files_free{fstype!="",job="node-exporter"}[6h], 24 * 60 * 60) < 0 and node_filesystem_readonly{fstype!="",job="node-exporter"} == 0)
      desc: Filesystem is predicted to run out of inodes within the next 24 hours.
    - name: NodeFilesystemAlmostOutOfSpace
      rule: (node_filesystem_avail_bytes{fstype!="",job="node-exporter"} / node_filesystem_size_bytes{fstype!="",job="node-exporter"} * 100 < 5 and node_filesystem_readonly{fstype!="",job="node-exporter"} == 0)
      desc: Filesystem has less than 5% space left.
    - name: NodeClockSkewDetected
      rule: (node_timex_offset_seconds > 0.05 and deriv(node_timex_offset_seconds[5m]) >= 0) or (node_timex_offset_seconds < -0.05 and deriv(node_timex_offset_seconds[5m]) <= 0)
      desc: Clock skew detected.
    - name: KubePodCrashLooping
      rule: max_over_time(kube_pod_container_status_waiting_reason{job="kube-state-metrics",reason="CrashLoopBackOff"}[5m]) >= 1
      desc: Pod is crash looping.
    - name: KubePodNotReady
      rule: sum by(namespace, pod) (max by(namespace, pod) (kube_pod_status_phase{job="kube-state-metrics",phase=~"Pending|Unknown"}) * on(namespace, pod) group_left(owner_kind) topk by(namespace, pod) (1, max by(namespace, pod, owner_kind) (kube_pod_owner{owner_kind!="Job"}))) > 0
      desc: Pod has been in a non-ready state for more than 15 minutes.
    - name: KubeQuotaAlmostFull
      rule: kube_resourcequota{job="kube-state-metrics",type="used"} / ignoring(instance, job, type) (kube_resourcequota{job="kube-state-metrics",type="hard"} > 0) > 0.9 < 1
      desc: Namespace quota is going to be full.
    - name: KubeCPUOvercommit
      rule: sum(namespace_cpu:kube_pod_container_resource_requests:sum) - (sum(kube_node_status_allocatable{resource="cpu"}) - max(kube_node_status_allocatable{resource="cpu"})) > 0 and (sum(kube_node_status_allocatable{resource="cpu"}) - max(kube_node_status_allocatable{resource="cpu"})) > 0
      desc: Cluster has overcommitted CPU resource requests.
    - name: KubeMemoryOvercommit
      rule: sum(namespace_memory:kube_pod_container_resource_requests:sum) - (sum(kube_node_status_allocatable{resource="memory"}) - max(kube_node_status_allocatable{resource="memory"})) > 0 and (sum(kube_node_status_allocatable{resource="memory"}) - max(kube_node_status_allocatable{resource="memory"})) > 0
      desc: Cluster has overcommitted memory resource requests.
    - name: KubeVersionMismatch
      rule: count(count by(git_version) (label_replace(kubernetes_build_info{job!~"kube-dns|coredns"}, "git_version", "$1", "git_version", "(v[0-9]*.[0-9]*).*"))) > 1
      desc: Different semantic versions of Kubernetes components running.
    - name: KubeClientErrors
      rule: (sum by(instance, job, namespace) (rate(rest_client_requests_total{code=~"5.."}[5m])) / sum by(instance, job, namespace) (rate(rest_client_requests_total[5m]))) > 0.01
      desc: Kubernetes API server client is experiencing errors.

---

apiVersion: kubeeye.kubesphere.io/v1alpha2
kind: InspectRule
metadata:
  labels:
    app.kubernetes.io/name: inspectrule
    app.kubernetes.io/instance: inspectrule-sample
    app.kubernetes.io/part-of: kubeeye
    app.kubernetes.io/managed-by: kustomize
    app.kubernetes.io/created-by: kubeeye
    kubeeye.kubesphere.io/rule-group: inspectrule-sample
  name: inspect-rules-sysctl
  namespace: kubeeye-system
spec:
  sysctl:
    - name: net.ipv4.ip_forward
      rule: net.ipv4.ip_forward = 1
    - name: net.bridge.bridge-nf-call-arptables
      rule: net.bridge.bridge-nf-call-arptables = 1
    - name: net.bridge.bridge-nf-call-ip6tables
      rule: net.bridge.bridge-nf-call-ip6tables = 1
    - name: net.bridge.bridge-nf-call-iptables
      rule: net.bridge.bridge-nf-call-iptables = 1
    - name: net.ipv4.ip_local_reserved_ports
      rule: net.ipv4.ip_local_reserved_ports = "30000-32767"
    - name: vm.max_map_count
      rule: vm.max_map_count = 262144
    - name: vm.swappiness
      rule: vm.swappiness = 0
    - name: vm.overcommit_memory
      rule: vm.overcommit_memory = 1
    - name: fs.inotify.max_user_instances
      rule: fs.inotify.max_user_instances=524288
    - name: fs.inotify.max_user_watches
      rule: fs.inotify.max_user_watches=524288
    - name: kernel.pid_max
      rule: kernel.pid_max = 65535
    - name: fs.pipe-max-size
      rule: fs.pipe-max-size=4194304
    - name: net.core.netdev_max_backlog
      rule: net.core.netdev_max_backlog=65535
    - name: net.core.rmem_max
      rule: net.core.rmem_max = 33554432
    - name: net.core.wmem_max
      rule: net.core.wmem_max = 33554432
    - name: net.ipv4.tcp_max_syn_backlog
      rule: net.ipv4.tcp_max_syn_backlog = 1048576
    - name: net.ipv4.neigh.default.gc_thresh1
      rule: net.ipv4.neigh.default.gc_thresh1= 512
    - name: net.ipv4.neigh.default.gc_thresh2
      rule: net.ipv4.neigh.default.gc_thresh2 = 2048
    - name: net.ipv4.neigh.default.gc_thresh3
      rule: net.ipv4.neigh.default.gc_thresh3 = 4096
    - name: net.core.somaxconn
      rule: net.core.somaxconn = 32768
    - name: net.ipv4.conf.all.rp_filter
      rule: net.ipv4.conf.all.rp_filter = 1
    - name: net.ipv4.conf.default.rp_filter
      rule: net.ipv4.conf.default.rp_filter =1
    - name: net.ipv4.conf.eth0.arp_accept
      rule: net.ipv4.conf.eth0.arp_accept = 1
    - name: fs.aio-max-nr
      rule: fs.aio-max-nr=262144
    - name: net.ipv4.tcp_retries2
      rule: net.ipv4.tcp_retries2=15
    - name: net.ipv4.tcp_max_tw_buckets
      rule: net.ipv4.tcp_max_tw_buckets = 1048576
    - name: net.ipv4.tcp_max_orphans
      rule: net.ipv4.tcp_max_orphans=65535
    - name: net.ipv4.udp_rmem_min
      rule: net.ipv4.udp_rmem_min = 131072
    - name: net.ipv4.udp_wmem_min
      rule: net.ipv4.udp_wmem_min = 131072
